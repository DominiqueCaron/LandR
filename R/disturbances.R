utils::globalVariables(c(
  ":=", "..cols", "CFB", "ROS", "RSO",
  "agesKilled", "severity", "severityToleranceDif", "sim"
))

#' Disturbance functions
#'
#' @template cohortData
#' @template cohortDefinitionCols
#' @template calibrate
#' @template postFireRegenSummary
#' @param rstCurrentBurn raster layer with burnt pixels in `currentTime`.
#'   Usually generated by a fire spread module (or collection of modules) like
#'   `fireSense`. Values in the raster should contain 0's for unburnt pixels and
#'   values > 0 for burn pixels. NA's are assumed to be outside of the study area.
#' @param inactivePixelIndex an internal object to `Biomass_core` that track of
#'  inactive pixels.
#' @template pixelGroupMap
#' @param currentTime numeric. Current simulation time step (as in `time(sim)`)
#' @template rasterToMatch
#' @template species
#' @template sufficientLight
#' @template speciesEcoregion
#' @template initialB
#' @template successionTimestep
#' @template verbose
#'
#' @section Stand-replacing fire disturbances:
#'  `FireDisturbance()` simulates post-fire mortality, serotiny and regeneration sequentially occurring after a fire.
#'  Post-fire mortality is assumed to be 100% (stand-replacement). The serotiny and regeneration
#'  algorithms are based on those in LANDIS-II Biomass Succession extension, v3.2.1, with modifications
#'  see `details` below. Requires the following objects in `sim`:
#'  @template FireDisturbance.
#'  For any given burnt pixel, the function begins by killing all cohorts
#'  (i.e. removing them from `cohortData`). Then it activates serotiny for
#'  serotinous species that had been present pre-fire, and reprouting for reprouter
#'  species. Whether a species successfully regenerates via serotiny or resprouting
#'  depends on its traits (whether it is serotinous, resprouter, both or none;
#'  `species` table), pre-fire cohort age (in `cohortData` table), its light/shade
#'  requirements (`species` table) and its local `maxB` (`speciesEcoregion`)
#'  table (see Scheller & Miranda, 2015 and Scheller & Mladenoff, 2004 for details).
#'  Unlike in LANDIS-II Biomass Succession extension, v3.2.1, here we allow serotiny
#'  and resprouting to occur in the same pixel to reflect the competitive advantage
#'  of reprouters. However, for a given species only serotiny (takes precedence)
#'  or resprouting can be activated.
#'  The `species` table must contain the columns:
#'   - `sexualmature` -- age at sexual maturity
#'   - `postfireregen` -- post-fire regeneration strategy ("serotiny", "resprout" or "none")
#'   - `shadetolerance` -- shade tolerance value relative to *other* species.
#'   - `resproutage_min`, `resproutage_max` -- minimum and maximum age at which species can repsrout
#'   - `resproutprob` -- probability of resporuting success (before light/shade suitability is assessed)
#'
#' @return a list of objects to be exported to sim:
#'  - cohortData
#'  - pixelGroupMap
#'  - lastFireYear
#'  - treedFirePixelTableSinceLastDisp
#'  - serotinyResproutSuccessPixels
#'  - severityBMap
#'  - severityData
#'  - postFireRegenSummary (if `calibrate == TRUE` and `!is.null(postFireRegenSummary)`)
#'
#' @references Scheller, R.M. & Miranda, B.R. (2015). LANDIS-II Biomass Succession v3.2 Extension  – User Guide.
#' @references Scheller, R.M. & Mladenoff, D.J. (2004). A forest growth and biomass module for a landscape simulation model, LANDIS: design, validation, and application. Ecological Modelling, 180, 211–229.
#'
#' @importFrom terra ncell as.int
#'
#' @export
#' @rdname Disturbances
FireDisturbance <- function(cohortData = sim$cohortData, cohortDefinitionCols = c("pixelGroup", "age", "speciesCode"),
                            calibrate = FALSE, postFireRegenSummary = sim$postFireRegenSummary,
                            rstCurrentBurn = sim$rstCurrentBurn, inactivePixelIndex = sim$inactivePixelIndex,
                            pixelGroupMap = sim$pixelGroupMap, currentTime = NULL, rasterToMatch = sim$rasterToMatch,
                            species = sim$species, sufficientLight = sim$sufficientLight,
                            speciesEcoregion = sim$speciesEcoregion, initialB = 10,
                            successionTimestep = 10L,
                            verbose = getOption("LandR.verbose", TRUE)) {
  ## check
  if (is.null(currentTime)) {
    stop("Provide 'currentTime' as, e.g., time(sim).")
  }

  # the presence of valid fire can cause three processes:
  # 1. remove species cohorts from the pixels that have been affected.
  # 2. initiate the post-fire regeneration
  # 3. change of cohortdata and pixelgroup map
  # may be a supplementary function is needed to convert non-logical map
  # to a logical map
  if (isTRUE(getOption("LandR.assertions", TRUE))) {
    if (!identical(NROW(cohortData), NROW(unique(cohortData, by = cohortDefinitionCols)))) {
      stop("cohortData has duplicated rows, i.e., multiple rows with the same pixelGroup, speciesCode and age")
    }
  }

  ## save for later
  treedFirePixelTableSinceLastDispOrig <- copy(treedFirePixelTableSinceLastDisp)

  postFirePixelCohortData <- cohortData[0,]
  postFirePixelCohortData[, `:=`(pixelIndex = integer(),
                                 age = NULL, B = NULL, mortality = NULL,
                                 aNPPAct = NULL)]

  # In some cases sumB exists, but not always -- we want to remove it too here.
  if (isTRUE("sumB" %in% colnames(postFirePixelCohortData))) {
    set(postFirePixelCohortData, NULL, "sumB", NULL)
  }

  if (calibrate & is.null(postFireRegenSummary)) {  ## don't overwrite
    postFireRegenSummary <- data.table(year = numeric(),
                                       regenMode = character(),
                                       species = character(),
                                       numberOfRegen = numeric())
  }

  # if (!is.null(rstCurrentBurn)) { # anything related to fire disturbance
  #   if (extent(rstCurrentBurn) != extent(pixelGroupMap)) {
  #     rstCurrentBurn <- crop(rstCurrentBurn, extent(pixelGroupMap))
  #   }
  # }

  ## extract burn pixel indices/groups and remove potentially inactive pixels
  burnedLoci <- which(as.vector(rstCurrentBurn[]) > 0)
  treedBurnLoci <- if (length(inactivePixelIndex) > 0) {
    # These can burn other vegetation (grassland, wetland)
    burnedLoci[!(burnedLoci %in% inactivePixelIndex)] # this is to prevent evaluating the pixels that are inactive
  } else {
    burnedLoci
  }
  treedFirePixelTableSinceLastDisp <- if (length(treedBurnLoci) > 0) {
    data.table(pixelIndex = as.integer(treedBurnLoci),
               pixelGroup = as.integer(as.vector(pixelGroupMap[])[treedBurnLoci]),
               burnTime = currentTime)
  } else {
    data.table(pixelIndex = integer(0),
               pixelGroup = integer(0),
               burnTime = numeric(0))
  }

  ## TODO: Ceres: maybe this should come at the end, lest we introduce pixelGroups that burned in previous years,
  ## but aren't currently burning
  # treedFirePixelTableSinceLastDispOrig[, pixelGroup := as.integer(as.vector(pixelGroupMap[]))[pixelIndex]]
  # # append previous year's
  # treedFirePixelTableSinceLastDisp <- rbindlist(list(treedFirePixelTableSinceLastDispOrig,
  #                                                    treedFirePixelTableSinceLastDisp))

  ## make table spp/ecoregionGroup/age in burnt pixels
  burnedPixelCohortData <- cohortData[pixelGroup %in% unique(treedFirePixelTableSinceLastDisp$pixelGroup)]
  set(burnedPixelCohortData, NULL, c("B", "mortality", "aNPPAct"), NULL)

  ## select the pixels that have burned survivors and assess them
  burnedPixelTable <- treedFirePixelTableSinceLastDisp[pixelGroup %in% unique(burnedPixelCohortData$pixelGroup)]
  ## expand table to pixels
  burnedPixelCohortData <- burnedPixelTable[burnedPixelCohortData, allow.cartesian = TRUE,
                                            nomatch = 0, on = "pixelGroup"]

  ## CALCULATE SEVERITY -----------------------------
  ## add biomass-based severity to severityData
  severityData <- calcSeverityB(cohortData, burnedPixelCohortData)

  ## make severity map
  severityBMap <- rasterToMatch
  severityBMap[] <- rep(NA, ncell(rasterToMatch))
  severityBMap[severityData$pixelIndex] <- severityData$severityB

  ## CALCULATE SIDE SHADE -----------------------------
  # assume the fire burns all cohorts on site - siteShade calc is no longer part of serotiny.
  # sumB is not actually necessary, but added for consistency w/ Biomass_regenerationPM
  set(burnedPixelCohortData, NULL, c("sumB", "siteShade"), 0)
  setkey(burnedPixelCohortData, speciesCode)

  ## DO SEROTINY -----------------------------
  ## assess potential serotiny reg: add sexual maturity to the table and compare w/ age
  ## as long as one cohort is sexually mature, serotiny is activated
  serotinyOutputs <- doSerotiny(burnedPixelCohortData = burnedPixelCohortData,
                                species = species, currentTime = currentTime,
                                treedFirePixelTableSinceLastDisp = treedFirePixelTableSinceLastDisp,
                                sufficientLight = sufficientLight,
                                speciesEcoregion = speciesEcoregion,
                                calibrate = calibrate,
                                postFirePixelCohortData = postFirePixelCohortData,
                                postFireRegenSummary = postFireRegenSummary)

  postFirePixelCohortData <- serotinyOutputs$postFirePixelCohortData
  serotinyPixel <- serotinyOutputs$serotinyPixel

  if (!is.null(serotinyOutputs$postFireRegenSummary))
    postFireRegenSummary <- serotinyOutputs$postFireRegenSummary

  rm(serotinyOutputs)

  ## DO RESPROUTING --------------------------
  ## assess resprouting reproduction:
  ## basically same thing as serotiny
  resproutingOutputs <- doResprouting(serotinyPixel = serotinyPixel,
                                      treedFirePixelTableSinceLastDisp = treedFirePixelTableSinceLastDisp,
                                      burnedPixelCohortData = burnedPixelCohortData,
                                      postFirePixelCohortData = postFirePixelCohortData,
                                      currentTime = currentTime, species = species,
                                      sufficientLight = sufficientLight,
                                      calibrate = calibrate,
                                      postFireRegenSummary = postFireRegenSummary)

  postFirePixelCohortData <- resproutingOutputs$postFirePixelCohortData
  serotinyResproutSuccessPixels <- resproutingOutputs$serotinyResproutSuccessPixels
  if (!is.null(resproutingOutputs$postFireRegenSummary))
    postFireRegenSummary <- resproutingOutputs$postFireRegenSummary

  rm(resproutingOutputs)

  ## ADD NEW COHORTS -----------------------------
  ## add new cohorts to pixels where serotiny/regeneration were activated
  if (NROW(postFirePixelCohortData) > 0) {
    ## redo post-fire pixel groups by adding the maxPixelGroup to their ecoregionMap values
    if (!is.null(serotinyResproutSuccessPixels)) {

      # Add new cohorts to BOTH the cohortData and pixelGroupMap
      ## reclassify pixel groups as burnt (0L)
      if (verbose > 0)
        message(blue("Post serotiny and resprouting"))

      outs <- updateCohortData(newPixelCohortData = copy(postFirePixelCohortData),
                               cohortData = copy(cohortData),
                               pixelGroupMap = pixelGroupMap,
                               currentTime = round(currentTime),
                               speciesEcoregion = copy(speciesEcoregion),
                               cohortDefinitionCols = cohortDefinitionCols,
                               treedFirePixelTableSinceLastDisp = copy(treedFirePixelTableSinceLastDisp),
                               initialB = initialB,
                               successionTimestep = successionTimestep)

      cohortData <- outs$cohortData
      pixelGroupMap <- outs$pixelGroupMap
      pixelGroupMap <- as.int(pixelGroupMap)
      ##########################################################
      # rm missing cohorts (i.e., those pixelGroups that are gone due to the fire/treedFirePixelTableSinceLastDisp)
      ##########################################################
    }
  }

  lastFireYear <- currentTime
  ## TODO: Ceres potential bug fix. Move this from beginning to here.
  treedFirePixelTableSinceLastDispOrig[, pixelGroup := as.integer(as.vector(pixelGroupMap[]))[pixelIndex]]
  # append previous year's
  treedFirePixelTableSinceLastDisp <- rbindlist(list(treedFirePixelTableSinceLastDispOrig,
                                                     treedFirePixelTableSinceLastDisp))

  outList <- list(cohortData = cohortData, pixelGroupMap = pixelGroupMap,
                  lastFireYear = lastFireYear, treedFirePixelTableSinceLastDisp = treedFirePixelTableSinceLastDisp,
                  serotinyResproutSuccessPixels = serotinyResproutSuccessPixels,
                  severityBMap = severityBMap, severityData = severityData)
  if (!is.null(postFireRegenSummary))
    outList <- c(outList, postFireRegenSummary = postFireRegenSummary)

  return(outList)
}

#' @section Partial severity (i.e. mortality) fire disturbances:
#'  `FireDisturbancePM()` simulates partial post-fire mortality, serotiny and regeneration
#'  sequentially after a fire. The level of mortality depends of fire severity,
#'  and, by default, follows the mechanisms in LANDIS-II Dynamic Fire System v3.0.
#'  Serotiny and regeneration algorithms algorithms are based on those in
#'  LANDIS-II Biomass Succession extension, v3.2.1, with modifications (see `FireDisturbance()`).
#'  Requires the following objects in `sim`:
#'  @template FireDisturbance
#'   - `fireDamageTable`
#'   - `fireRSORas` (optional)
#'   - `fireROSRas`
#'   - `fireCFBRas`
#'   - `minRelativeB`
#'  Rasters of fire behaviour properties (`fireRSORas`, `fireROSRas` and `fireCFBRas`)
#'  can be calculated using the `cffdrs` package.
#'  The `species` table must contain the columns:
#'   - `firetolerance` -- fire tolerance value relative to *other* species.
#'   - `longevity` -- maximum species age
#'   - `sexualmature` -- age at sexual maturity
#'   - `postfireregen` -- post-fire regeneration strategy ("serotiny", "resprout" or "none")
#'   - `shadetolerance` -- shade tolerance value relative to *other* species.
#'   - `resproutage_min`, `resproutage_max` -- minimum and maximum age at which species can repsrout
#'   - `resproutprob` -- probability of resporuting success (before light/shade suitability is assessed)
#'
#' @param colsForPixelGroups character. `cohortData` columns used to find identical pixels in terms of
#'   cohort composition, and group them into `pixelGroups`.
#' @param LANDISPM logical. Should partial mortality be calculated as in LANDIS-II Dynamic Fire System v3.0.
#'   Must be `TRUE` for the time being.
#' @param fireDamageTable `data.table` defining upper age limit of cohorts killed by fire.
#'   See LANDIS-II Dynamic Fire System v3.0 Manual for an example.
#' @param fireRSORas raster layer of critical spread rate for crowning (m/min) for each burned pixel.
#' @param fireROSRas raster layer of equilibrium rate of spread (m/min) for each burned pixel.
#' @param fireCFBRas raster layer of crown fraction burnt for each burned pixel.
#' @template minRelativeB
#'
#' @references Sturtevant, B.R., Miranda, B.R., Scheller, R.M. & Shinneman, D. (2018). LANDIS-II Dynamic Fire System Extension v3.0  – User Guide.
#'
#' @importFrom crayon red
#' @importFrom terra ncell as.int
#'
#' @export
#' @rdname Disturbances
FireDisturbancePM <- function(cohortData = sim$cohortData, cohortDefinitionCols = c("pixelGroup", "age", "speciesCode"),
                              colsForPixelGroups = LandR::columnsForPixelGroups,
                              calibrate = FALSE, LANDISPM = TRUE, postFireRegenSummary = sim$postFireRegenSummary,
                              rstCurrentBurn = sim$rstCurrentBurn, inactivePixelIndex = sim$inactivePixelIndex,
                              pixelGroupMap = sim$pixelGroupMap, currentTime = NULL, rasterToMatch = sim$rasterToMatch,
                              fireDamageTable = sim$fireDamageTable, fireRSORas = sim$fireRSORas, fireROSRas = sim$fireROSRas,
                              fireCFBRas = sim$fireCFBRas, species = sim$species, sufficientLight = sim$sufficientLight,
                              speciesEcoregion = sim$speciesEcoregion, initialB = 10,
                              minRelativeB = sim$minRelativeB, successionTimestep = 10L,
                              verbose = getOption("LandR.verbose", TRUE)) {
  ## check
  if (is.null(currentTime)) {
    stop("Provide 'currentTime' as, e.g., time(sim).")
  }

  # the presence of valid fire can cause three processes:
  # 1. partially remove species cohorts from the pixels that have been affected.
  # 2. initiate the post-fire regeneration (serotiny and/or resprouting)
  # 3. change of cohortdata and pixelgroup map

  ## checks
  ## partial mortality needs the following objects
  if (any(!is.null(fireRSORas),
          !is.null(fireROSRas),
          !is.null(fireCFBRas))) {
    message(red(paste0("Biomass_regenerationPM is missing one/several of the following rasters:\n",
                       "  fireRSORas, fireROSRas and fireCFBRas.\n",
                       "  DUMMY RASTERS will be used - if this is not intended, please \n",
                       "  use a fire module that provides them (e.g. FavierFireSpread)")))
    vals <- as.vector(rstCurrentBurn[])
    valsRSO <- valsROS <- valsCFB <- integer(0)
    valsRSO[!is.na(vals)] <- as.integer(round(runif(sum(!is.na(vals)), 0, 100)))
    valsROS[!is.na(vals)] <- as.integer(round(runif(sum(!is.na(vals)), 0, 100)))
    valsCFB[!is.na(vals)] <- runif(sum(!is.na(vals)), 0, 1)

    fireRSORas <- fireROSRas <- fireCFBRas <- rstCurrentBurn
    fireRSORas[] <- valsRSO
    fireROSRas[] <- valsROS
    fireCFBRas[] <- valsCFB
  }

  if (isTRUE(getOption("LandR.assertions", TRUE))) {
    if (!identical(NROW(cohortData), NROW(unique(cohortData, by = c("pixelGroup", "speciesCode", "age", "B"))))) {
      stop("cohortData has duplicated rows, i.e., multiple rows with the same pixelGroup, speciesCode and age")
    }
  }

  ## save for later
  treedFirePixelTableSinceLastDispOrig <- copy(treedFirePixelTableSinceLastDisp)

  ## make table where survivor, serotiny and resprouting cohorts will be stored
  postFirePixelCohortData <- cohortData[0,]
  postFirePixelCohortData[, `:=`(pixelIndex = integer(),
                                 age = NULL, B = NULL, mortality = NULL,
                                 aNPPAct = NULL)]

  # In some cases sumB exists, but not always -- we want to remove it too here.
  if (isTRUE("sumB" %in% colnames(postFirePixelCohortData))) {
    set(postFirePixelCohortData, NULL, "sumB", NULL)
  }

  if (calibrate & is.null(postFireRegenSummary)) {   # don't overwrite
    postFireRegenSummary <- data.table(year = numeric(),
                                       regenMode = character(),
                                       species = character(),
                                       numberOfRegen = numeric())
  }

  ## extract burn pixel indices/groups and remove potentially inactive pixels
  burnedLoci <- which(as.vector(rstCurrentBurn[]) > 0)
  treedBurnLoci <- if (length(inactivePixelIndex) > 0) {
    # These can burn other vegetation (grassland, wetland)
    burnedLoci[!(burnedLoci %in% inactivePixelIndex)] # this is to prevent evaluating the pixels that are inactive
  } else {
    burnedLoci
  }

  treedFirePixelTableSinceLastDisp <- data.table(pixelIndex = as.integer(treedBurnLoci),
                                                 pixelGroup = as.integer(as.vector(pixelGroupMap[])[treedBurnLoci]),
                                                 burnTime = currentTime)

  ## TODO: Ceres: I don't think we should be bring in the previously burnt pixelGroups at this point
  ##  solution (?) code was copy-pasted to before the export to sim
  # ## update past pixelGroup number to match current ones.
  # treedFirePixelTableSinceLastDispOrig[, pixelGroup := as.integer(as.vector(pixelGroupMap[]))[pixelIndex]]
  # # append previous year's
  # treedFirePixelTableSinceLastDisp <- rbindlist(list(treedFirePixelTableSinceLastDispOrig,
  #                                                    treedFirePixelTableSinceLastDisp))

  ## make table spp/ecoregionGroup/age in burnt pixels
  burnedPixelCohortData <- cohortData[pixelGroup %in% unique(treedFirePixelTableSinceLastDisp$pixelGroup)]
  # set(burnedPixelCohortData, NULL, c("B", "mortality", "aNPPAct"), NULL)
  # set(burnedPixelCohortData, ,c("sumB", "siteShade"), 0) # assume the fire burns all cohorts on site
  setkey(burnedPixelCohortData, speciesCode)

  ## DO MORTALITY ----------------------------
  ## TODO: MOVE SEVERITY ESTIMATES TO A SEVERITY MODULE (?)
  ## LANDIS-II Dynamic Fire System v3.0
  ## estimate fire severity from crown fraction burnt (CFB),
  ## equilibrium head fire rate of spread (ROS) and critical spread rate for crowning (RSO)

  ## select the pixels that have potential survivors and assess them
  burnedPixelTable <- treedFirePixelTableSinceLastDisp[pixelGroup %in% unique(burnedPixelCohortData$pixelGroup)]

  ## from now on the survivor process is assessed per pixel (to ensure compatibility with serotiny/resprout tables)
  burnedPixelCohortData <- burnedPixelTable[burnedPixelCohortData, allow.cartesian = TRUE,
                                            nomatch = 0, on = "pixelGroup"]

  severityData <- data.table(pixelIndex = 1:ncell(pixelGroupMap),
                             pixelGroup = as.vector(pixelGroupMap[]),
                             burntPixels = as.vector(rstCurrentBurn[]),
                             RSO = as.vector(fireRSORas[]),
                             ROS = as.vector(fireROSRas[]),
                             CFB = as.vector(fireCFBRas[]))
  severityData <- na.omit(severityData)

  severityData[CFB < 0.1 & ROS < (RSO + 0.458)/2, severity := 1]
  severityData[CFB < 0.1 & ROS >= (RSO + 0.458)/2, severity := 2]
  severityData[CFB >= 0.1 & CFB < 0.495, severity := 3]
  severityData[CFB >= 0.495 & CFB < 0.9, severity := 4]
  severityData[CFB >= 0.9, severity := 5]

  ## rm unnecessary cols
  severityData <- severityData[, .(pixelIndex, pixelGroup, severity)]

  ## add severity to survivor table.
  if (isTRUE(getOption("LandR.assertions", TRUE)))
    if (!all(burnedPixelCohortData$pixelGroup %in% severityData$pixelGroup)) {
      warning("Some burnt pixels no fire behaviour indices or severity.\n",
              "Please debug Biomass_regenerationPM::fireDisturbance")
    }
  burnedPixelCohortData <- severityData[burnedPixelCohortData,
                                        on = .(pixelGroup, pixelIndex),
                                        allow.cartesian = TRUE]

  ## DO MORTALITY -----------------------------
  ## Highest severity kills all cohorts
  burnedPixelCohortData[severity == 5, `:=` (B = 0, mortality = 0, aNPPAct = 0)]

  if (LANDISPM) {
    ## FIRE DAMAGE ---------------------------
    ## 1) Calculate site fire damage per cohort/species as severity - fire tolerance
    ## 2) lookup the fire damage values on the fire damage table to decide cohort ages to kill
    ## 3) for values that are not on the table, either the cohort/species is not affected or its totally killed

    ## add fire tolerance and longevity
    burnedPixelCohortData <- burnedPixelCohortData[species[, .(speciesCode, longevity, firetolerance)],
                                                   on = "speciesCode", nomatch = 0]
    ## calculate dif between severity and tolerance
    burnedPixelCohortData[, severityToleranceDif := severity - firetolerance]
    assertFireToleranceDif(burnedPixelCohortData)

    ## find the % reduction in biomass:
    ## agesKilled w/ NAs come from observed severityToleranceDif having no matches in table,
    ## so they are beyond the range of values
    ## if the observed severityToleranceDif is higher than table values, then  the fire damage is maximum
    ## if the observed severityToleranceDif is lower than table values, then there is no fire damage
    burnedPixelCohortData <- fireDamageTable[burnedPixelCohortData, on = "severityToleranceDif",
                                             nomatch = NA]

    if (isTRUE(getOption("LandR.assertions", TRUE))) {
      if (!all(is.na(burnedPixelCohortData[(severityToleranceDif > max(fireDamageTable$severityToleranceDif) &
                                            severityToleranceDif < min(fireDamageTable$severityToleranceDif)),
                                           agesKilled])))
        stop("The join of fireDamageTable and burnedPixelCohortData went wrong. agesKilled should be NA
               for site fire damage values outside the range of values in fireDamageTable")
    }

    ## add extreme values
    burnedPixelCohortData[severityToleranceDif > max(fireDamageTable$severityToleranceDif),
                          agesKilled := 1.0]
    burnedPixelCohortData[severityToleranceDif < min(fireDamageTable$severityToleranceDif),
                          agesKilled := 0.0]

    ## and kill cohorts below longevity * prop. - still not partial cohort mortality
    ## but partial stand mortality  -- a lot are being killed because longevities are so large now (disparity from landis)
    burnedPixelCohortData[age/longevity <= agesKilled,
                          `:=`(B = 0, mortality = 0, aNPPAct = 0)]

    ## remove unnecessary cols, but keep dead cohorts for serotiny/resprouting
    cols <- c("pixelGroup", "pixelIndex", "speciesCode",
              "ecoregionGroup", "age", "B", "mortality", "aNPPAct")
    burnedPixelCohortData <- burnedPixelCohortData[, ..cols]

    ## calculate amount of biomass lost per pixel and make severityMap
    ## add biomass-based severity to severityData
    severityData2 <- calcSeverityB(cohortData, burnedPixelCohortData)
    cols <- c("pixelGroup", "pixelIndex")
    severityData <- severityData[severityData2, on = cols]

    ## make severity map
    severityBMap <- rasterToMatch
    severityBMap[] <- rep(NA, ncell(rasterToMatch))
    severityBMap[severityData$pixelIndex] <- severityData$severityB
  } else {
    ## TODO MAYBE KEEP THE SAME SEVERITY NOTION, BUT THEN USE cfb TO DETERMINE AMOUNT OF BIOMASS
    ## REMOVED PER COHORT ON AN INVERSE AGE WEIGHTED AWAY
    ## USE SPECIES TRAITS TO WEIGHT BIOMASS REMOVAL WITHIN EACH COHORT
    stop("Only LANDIS-II partial mortality mechanisms have been implemented. ",
         "Set 'LANDISPM' to TRUE.")
  }

  ## CALCULATE SIDE SHADE -----------------------------
  siteShade <- data.table(calcSiteShade(currentTime = round(currentTime), burnedPixelCohortData,
                                        speciesEcoregion, minRelativeB))

  burnedPixelCohortData <- siteShade[burnedPixelCohortData, on = "pixelGroup", nomatch = NA]
  burnedPixelCohortData[is.na(siteShade), siteShade := 0]
  rm(siteShade)

  ## clean burnedPixelCohortData from unnecessary columns
  # set(burnedPixelCohortData, NULL, c("B", "mortality", "aNPPAct"), NULL)
  set(burnedPixelCohortData, NULL, c("mortality", "aNPPAct"), NULL)
  # set(burnedPixelCohortData, ,c("sumB", "siteShade"), 0) # assume the fire burns all cohorts on site
  setkey(burnedPixelCohortData, speciesCode)

  ## DO SEROTINY -----------------------------
  ## assess potential serotiny reg: add sexual maturity to the table and compare w/ age
  ## as long as one cohort is sexually mature, serotiny is activated
  serotinyOutputs <- doSerotiny(burnedPixelCohortData = burnedPixelCohortData,
                                species = species, currentTime = currentTime,
                                treedFirePixelTableSinceLastDisp = treedFirePixelTableSinceLastDisp,
                                sufficientLight = sufficientLight,
                                speciesEcoregion = speciesEcoregion,
                                calibrate = calibrate,
                                postFirePixelCohortData = postFirePixelCohortData,
                                postFireRegenSummary = postFireRegenSummary)

  postFirePixelCohortData <- serotinyOutputs$postFirePixelCohortData
  serotinyPixel <- serotinyOutputs$serotinyPixel

  if (!is.null(serotinyOutputs$postFireRegenSummary))
    postFireRegenSummary <- serotinyOutputs$postFireRegenSummary

  rm(serotinyOutputs)

  ## DO RESPROUTING --------------------------
  ## assess resprouting reproduction:
  ## basically same thing as serotiny
  resproutingOutputs <- doResprouting(serotinyPixel = serotinyPixel,
                                      treedFirePixelTableSinceLastDisp = treedFirePixelTableSinceLastDisp,
                                      burnedPixelCohortData = burnedPixelCohortData,
                                      postFirePixelCohortData = postFirePixelCohortData,
                                      currentTime = currentTime, species = species,
                                      sufficientLight = sufficientLight,
                                      calibrate = calibrate,
                                      postFireRegenSummary = postFireRegenSummary)

  postFirePixelCohortData <- resproutingOutputs$postFirePixelCohortData
  serotinyResproutSuccessPixels <- resproutingOutputs$serotinyResproutSuccessPixels
  if (!is.null(resproutingOutputs$postFireRegenSummary))
    postFireRegenSummary <- resproutingOutputs$postFireRegenSummary

  rm(resproutingOutputs)

  ## ADD NEW COHORTS -----------------------------
  ## add new cohorts to pixels where serotiny/regeneration were activated
  if (NROW(postFirePixelCohortData)) {
    ## redo post-fire pixel groups by adding the maxPixelGroup to their ecoregioMap values
    if (!is.null(serotinyResproutSuccessPixels)) {

      # Add new cohorts to BOTH the cohortData and pixelGroupMap
      ## reclassify pixel groups as burnt (0L)
      if (verbose > 0)
        message(blue("Post serotiny and resprouting"))

      ## add the survivors cohorts to the serotiny/reprouting ones
      cols <- c("pixelGroup", "pixelIndex", "speciesCode", "ecoregionGroup", "age", "B")
      postFirePixelCohortData <- rbind(postFirePixelCohortData, burnedPixelCohortData[B > 0, ..cols],
                                       use.names = TRUE, fill = TRUE)
      postFirePixelCohortData[is.na(type), type := "survivor"]

      ## set ages to 1 here, because updateCohortData will only so so if there isn't an age column
      postFirePixelCohortData[is.na(age), age := 1L]

      ## filter cohortData to only have unburnt pixels -- this is not sufficient!!!
      ## in PGs where cohorts die in one but not other pixels, these cohorts from other pixels are added back where they were supposed to be removed.
      # unburnedPCohortData <- addPixels2CohortData(copy(sim$cohortData), sim$pixelGroupMap)
      # unburnedPCohortData <- unburnedPCohortData[!pixelIndex %in% treedFirePixelTableSinceLastDisp$pixelIndex]
      # set(unburnedPCohortData, NULL, "pixelIndex", NULL)  ## collapse pixel groups again
      # unburnedPCohortData <- unburnedPCohortData[!duplicated(unburnedPCohortData)]

      ## redo PGs in all burnt pixels
      ## 1) we need to create a table of unburt pixels and burnt pixels with dead and surviving cohorts,
      ## but not new cohorts (serotiny/resprout) -- these are added by updateCohortData
      ## 2) then remove dead cohorts for updateCohortData and redo PG
      ## the PGs need to be done twice otherwise, once to account for cohorts that only died in some but not all pixels of a given
      ## pixelGroup, and the second time to ensure that pixels that became similar after the death of some cohorts can
      ## be grouped together.

      tempObjs <- genPGsPostDisturbance(cohortData = sim$cohortData,
                                        pixelGroupMap = sim$pixelGroupMap,
                                        disturbedPixelTable = treedFirePixelTableSinceLastDisp,
                                        disturbedPixelCohortData = burnedPixelCohortData,
                                        colsForPixelGroups = colsForPixelGroups,
                                        doAssertion = getOption("LandR.assertions", TRUE))

      outs <- updateCohortData(newPixelCohortData = copy(postFirePixelCohortData),
                               cohortData = copy(tempObjs$cohortData),
                               pixelGroupMap = tempObjs$pixelGroupMap,
                               currentTime = round(currentTime),
                               speciesEcoregion = copy(speciesEcoregion),
                               treedFirePixelTableSinceLastDisp = copy(treedFirePixelTableSinceLastDisp),
                               successionTimestep = successionTimestep)

      assertPostFireDist(cohortData = tempObjs$cohortData, pixelGroupMap = tempObjs$pixelGroupMap,
                         cohortDataNew = outs$cohortData, pixelGroupMapNew = outs$pixelGroupMap,
                         postFirePixelCohortData = postFirePixelCohortData,
                         burnedPixelCohortData = burnedPixelCohortData,
                         doAssertion = getOption("LandR.assertions", TRUE))

      cohortData <- outs$cohortData
      pixelGroupMap <- outs$pixelGroupMap
      pixelGroupMap <- as.int(pixelGroupMap)
    }
  }

  lastFireYear <- currentTime

  ## TODO: Ceres: moved this to here to avoid re-killing/serotiny/repsoruting pixelGroups that burned in the previous year.
  ## update past pixelGroup number to match current ones.
  treedFirePixelTableSinceLastDispOrig[, pixelGroup := as.integer(as.vector(pixelGroupMap[]))[pixelIndex]]
  # append previous year's
  treedFirePixelTableSinceLastDisp <- rbindlist(list(treedFirePixelTableSinceLastDispOrig,
                                                     treedFirePixelTableSinceLastDisp))

  outList <- list(cohortData = cohortData, pixelGroupMap = pixelGroupMap,
                  lastFireYear = lastFireYear, treedFirePixelTableSinceLastDisp = treedFirePixelTableSinceLastDisp,
                  serotinyResproutSuccessPixels = serotinyResproutSuccessPixels,
                  severityBMap = severityBMap, severityData = severityData)
  if (!is.null(postFireRegenSummary))
    outList <- c(outList, postFireRegenSummary = postFireRegenSummary)
  if (!is.null(postFireRegenSummary))
    outList <- c(outList, postFireRegenSummary = postFireRegenSummary)

  return(outList)
}


# PeatlandThermokarst <- function()

#' Re-generate new `pixelGroup`s in partially disturbed pixels.
#'
#' @details This function regenerates `pixelGroup`s in situations where
#'  disturbances are not stand-replacing and create survivors/dead cohorts
#'  in some, but potentially not all, pixels of a `pixelGroup`. This is
#'  necessary to prevent reintroducing dead cohorts that were not affected
#'  in the other pixels of the same, original, `pixelGroup`.
#'  **ATTENTION** This function alone will not generate final `pixelGroups`,
#'  and will likely need to be followed by an `updateCohortData` run.
#'
#' @param cohortData `data.table`. The pre-disturbance `cohortData` table
#' @param pixelGroupMap `SpatRaster`. The pre-disturbance `pixelGroupMap`.
#' @param disturbedPixelTable `data.table`. A table with at least the `pixelIndex`
#'  of all disturbed pixels. Additional columns are ignored.
#' @param disturbedPixelCohortData a `cohortData`-like table with information of dead,
#'  and surviving, but *NOT* regenerating cohorts (cohorts for whom regeneration via, e.g., serotiny
#'  or resprouting was succesfully activated), in *disturbed pixels only*. Dead cohorts should
#'  age B == 0, surviving cohorts B > 0.
#' @template doAssertion
#'
#' @return a named list with:
#'  -   a `cohortData` table with the updated `pixelGroups`, as well as
#'  survivor cohorts, but not dead cohorts.
#'  -   a `pixelGroupMap` with the updated `pixelGroups` in disturbed pixels
#'
#' @export
genPGsPostDisturbance <- function(cohortData, pixelGroupMap,
                                  disturbedPixelTable, disturbedPixelCohortData,
                                  colsForPixelGroups = LandR::columnsForPixelGroups,
                                  doAssertion = getOption("LandR.assertions", TRUE)) {
  ## check - are there duplicated cohorts, dead, surviving or regenerating in a given pixel?
  cols <- c("pixelIndex", "speciesCode", "age", "B")
  if (any(duplicated(disturbedPixelCohortData[, ..cols]))) {
    stop("There are duplicated dead/surviving/regenerating cohorts for a given species/pixel combination")
  }

  unburnedPCohortData <- addPixels2CohortData(copy(cohortData), pixelGroupMap)
  unburnedPCohortData <- unburnedPCohortData[!pixelIndex %in% disturbedPixelTable$pixelIndex]
  newPCohortData <- rbind(unburnedPCohortData, disturbedPixelCohortData, fill = TRUE)

  cd <- newPCohortData[, c("pixelIndex", colsForPixelGroups), with = FALSE]
  newPCohortData[, pixelGroup := generatePixelGroups(cd, maxPixelGroup = 0L, columns = colsForPixelGroups)]

  ## update PGMap
  pixelGroupMap[newPCohortData$pixelIndex] <- newPCohortData$pixelGroup

  if (doAssertion) {
    test <- setdiff(which(!is.na(pixelGroupMap[])), newPCohortData$pixelIndex)
    if (any(pixelGroupMap[test] != 0)) {
      stop("Bug in Biomass_regenerationPM: pixels w/o information in burnt and unburnt pixelCohortData tables")
    }
  }

  ## remove dead cohorts and re-do pixelGroups
  newPCohortData <- newPCohortData[B > 0]
  cd <- newPCohortData[, c("pixelIndex", columnsForPixelGroups), with = FALSE]
  newPCohortData[, pixelGroup := generatePixelGroups(cd, maxPixelGroup = 0L, columns = columnsForPixelGroups)]
  pixelGroupMap[newPCohortData$pixelIndex] <- newPCohortData$pixelGroup

  ## collapse to PGs
  tempCohortData <- copy(newPCohortData)
  set(tempCohortData, NULL, "pixelIndex", NULL)
  cols <- names(cohortData)   ## need to follow cohortData as there may be other columns in tempCohortData (e.g. siteShade)
  tempCohortData <- tempCohortData[!duplicated(tempCohortData[, .SD, .SDcols = cols])]

  return(list(cohortData = tempCohortData, pixelGroupMap = pixelGroupMap))
}

