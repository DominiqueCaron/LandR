% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/permafrost.R
\name{assignPresences}
\alias{assignPresences}
\title{Assign presences to patches based on a raster or presence probabilities}
\usage{
assignPresences(
  assignProb,
  landscape,
  pixToConvert = NULL,
  probWeight = 1,
  numStartsDenom = 10
)
}
\arguments{
\item{assignProb}{a \code{SpatRaster} of presence probabilities (\code{NA} allowed)}

\item{landscape}{a \code{SpatRaster} of the entire landscape with \code{NA} outside patches}

\item{pixToConvert}{numeric. Number of pixels to convert to presence across \code{landscape}.
If \code{NULL}, it will convert \code{round(sum(!is.na(landscape[]))/2)} pixels.}

\item{probWeight}{numeric. A weight for \code{assignProb} (\code{assignProb^probWeight})
which affects the degree of clumping (higher weights result in clumpier patterns)}

\item{numStartsDenom}{integer. Used to calculate the number of starting pixels
(as \code{pixToConvert/numStartsDenom}) at each try of assigning presences.}
}
\value{
a \code{SpatRaster} object
}
\description{
Assign presences to patches based on a raster or presence probabilities
}
\details{
This function attempts to iteratively assign
presences starting in \code{pixToConvert/numStartsDenom} pixels
sampled from areas with high probabilities in \code{assignProb} (weighted if
\code{probWeight != 1}).
For each starting pixel, it assigns a maximum of \code{numStartsDenom * probWeight}
pixels. If not enough pixels are assigned presences (i.e. the number of
presences does not reach \code{pixToConvert}), the function tries again
after increasing \code{assignProb} by a factor of \code{1.5} (with values > 1 capped at 1).
If too many pixels are assigned presences, pixels are sampled according to
\code{assignProb ^ 10} (where \code{assignProb} corresponds to the original supplied values.)
}
\examples{
library(terra)
library(raster)
library(SpaDES.tools)
set.seed(123)
ras <- raster(extent(0, 100, 0, 100), res = 1, vals = 0)
ras[] <- 1L
ras_nas <- randomPolygons(raster(extent(0, 100, 0, 100), res = 1, vals = 0), numTypes = 200)
ras_nas[ras_nas[] \%in\% sample(ras_nas[], 120)] <- NA
ras <- mask(ras, ras_nas)
ras <- rast(ras)
## NA patches to calculate distance
ras_nas <- ras
ras_nas[] <- 1L
ras_nas <- mask(ras_nas, ras, inverse = TRUE)
plot(ras, col = "lightgreen")
plot(ras_nas, add = TRUE, col = "coral")

## distance from NAs
ras_distance <- distance(ras_nas)
plot(ras_distance)

spreadProbRas <- ras_distance/minmax(ras_distance)["max",]
# spreadProbRas <- mask(spreadProbRas, ras)
# spreadProbRas[is.na(spreadProbRas[])] <- 0
spreadProbRas[as.vector(spreadProbRas[]) == 0] <- NA
plot(spreadProbRas)

## varying pixels and weights
weights <- seq(0.5, 7, length.out = 5)
## we are in a case where we want fewer pixels than available
pixToConvert <- round(sum(!is.na(ras[]))/4 * seq(0.5, 2, length.out = length(weights)))
tests <- Map(probWeight = weights,   ## not much difference in clumping levels
             pixToConvert = pixToConvert,
             numStartsDenom = pixToConvert/10,
             f = assignPresences,
             MoreArgs = list(assignProb = spreadProbRas,
                             landscape = ras))

names(tests) <- paste(paste("Prob. weight", weights),
                      paste("no pix", c(pixToConvert)),
                      sep = ";")

plot(rast(tests), col = "lightblue")

## Function to iterate over several landscape configurations,
## weights and no. pixels desired.
testFun <- function(NAgroups = 5, varyWeights = TRUE, varyPixels = TRUE) {
  set.seed(123)
  ras <- raster(extent(0, 100, 0, 100), res = 1, vals = 0)
  ras[] <- 1L
  ras_nas <- randomPolygons(raster(extent(0, 100, 0, 100), res = 1, vals = 0), numTypes = 200)
  ras_nas[ras_nas[] \%in\% sample(unique(ras_nas[]), NAgroups)] <- NA
  ras <- mask(ras, ras_nas)
  ras <- rast(ras)
  ## NA patches to calculate distance
  ras_nas <- ras
  ras_nas[] <- 1L
  ras_nas <- mask(ras_nas, ras, inverse = TRUE)

  ## distance from NAs
  ras_distance <- distance(ras_nas)

  spreadProbRas <- ras_distance/minmax(ras_distance)["max",]
  spreadProbRas[as.vector(spreadProbRas[]) == 0] <- NA

  ## varying weights
  if (varyWeights) {
    weights <- c(2, 3, 7)   ## higher values increase aggregation (decrease edge:area)
  } else {
    weights <- rep(2, 3)
  }

  ## we are in a case where we want fewer pixels than available
  totalPix <- ncell(ras)
  totalAvailPix <- sum(!is.na(ras[]))
  pixToConvert <- round(totalAvailPix/4)
  availToNARatio <- totalAvailPix/totalPix

  ## varying no. pixels to convert
  if (varyPixels) {
    pixToConvert <- round(pixToConvert * c(0.5, 1, 1.5))
  }

  ## for landscapes with very high availToNARatio we
  ## bump the weights to increase aggregation
  weights <- weights*(1+availToNARatio*2)

  if (!varyWeights & !varyPixels) {
    weights <- unique(weights)
    pixToConvert <- unique(pixToConvert)
  }

  tests <- Map(probWeight = weights,   ## not much difference in clumping levels
               pixToConvert = pixToConvert,
               numStartsDenom = pixToConvert/10,
               f = assignPresences,
               MoreArgs = list(assignProb = spreadProbRas,
                               landscape = ras))
  if (length(tests) == 1) {
    tests <- tests[[1]]
  } else {
    tests <- rast(tests)
  }
  names(tests) <- paste(paste("Prob. weight", weights),
                        paste("no pix", pixToConvert),
                        sep = ";")
  return(tests)
}

}
